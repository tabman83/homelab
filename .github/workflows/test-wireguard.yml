name: Test WireGuard Tunnel

on:
  workflow_dispatch:   # manually trigger from GitHub UI
  #push:
    #branches:
      #- main 
jobs:
  test-wireguard:
    runs-on: ubuntu-latest
    env:
      PROXMOX_VE_ENDPOINT:       ${{ secrets.PROXMOX_API_URL }}
      PROXMOX_VE_API_TOKEN:      ${{ secrets.PROXMOX_API_TOKEN_ID }}=${{ secrets.PROXMOX_API_TOKEN_SECRET }}
      TF_TOKEN_app_terraform_io: ${{ secrets.TF_TOKEN_APP_TERRAFORM_IO }}

    steps:
      # Checkout repo so Terraform files are available
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Install WireGuard
        run: sudo apt install -y wireguard

      - name: Bring up WireGuard
        run: |
          echo "${{ secrets.WIREGUARD_PRIVATE_KEY }}" > privatekey
          sudo ip link add dev wg0 type wireguard
          sudo ip address add dev wg0 192.168.98.4/32      
          sudo wg set wg0 private-key privatekey peer ${{ secrets.WIREGUARD_PUBLIC_KEY }} allowed-ips 192.168.98.0/24,192.168.5.0/24 endpoint vpn.parisi.cloud:13231
          sudo ip link set up dev wg0
          sudo ip route add 192.168.5.0/24 dev wg0
          sudo resolvectl dns wg0 192.168.5.1
          sudo resolvectl domain wg0 local

      - name: Set up SSH key for Proxmox
        if: github.ref == 'refs/heads/master'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PROXMOX_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          rm -f ~/.ssh/known_hosts
          cat <<EOF >> ~/.ssh/config
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null

          Host proxmox
            HostName pve.local
            HostName pve2.local
            HostName pve3.local
            HostName proxmox.local
            User root
            IdentityFile ~/.ssh/id_rsa
          EOF

      - name: Ensure all referenced LXC templates exist on Proxmox
        if: github.ref == 'refs/heads/master'
        run: |
          # Find all ostemplate values in root .tf files (ignore modules/)
          templates=$(grep -hro 'ostemplate *= *"[^"]*"' . --exclude-dir=modules --include='*.tf' \
            | sed -E 's/.*"([^"]*)".*/\1/' \
            | sort -u)

          if [ -z "$templates" ]; then
            echo "No ostemplate entries found in root .tf files. Skipping template ensure."
            exit 0
          fi

          echo "Found ostemplates:"
          echo "$templates"

          # Run pveam update once
          echo "Updating Proxmox template list (pveam update)..."
          ssh proxmox "pveam update"

          # Loop over each template and ensure it exists
          for tpl in $templates; do
            [ -z "$tpl" ] && continue

            storage="${tpl%%:*}"      # e.g. 'local' from 'local:vztmpl/debian-12...'
            path="${tpl#*:}"          # e.g. 'vztmpl/debian-12...'
            filename="${path##*/}"    # e.g. 'debian-12-standard_12.0-1_amd64.tar.zst'

            echo
            echo "Checking template: $tpl"
            echo "  storage = $storage"
            echo "  path    = $path"
            echo "  file    = $filename"

            ssh proxmox "
              set -e
              if ! pveam list $storage | awk '{print \$1}' | grep -qx '$tpl'; then
                echo '  -> Missing, downloading via: pveam download $storage $filename'
                pveam download $storage '$filename'
              else
                echo '  -> Already present.'
              fi
            "
          done

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        run: terraform plan -out=plan

      - name: Terraform Apply
        if: github.ref == 'refs/heads/master'
        run: terraform apply -auto-approve plan

      - name: Export deploy targets from Terraform
        if: github.ref == 'refs/heads/master'
        run: terraform output -json deploy_targets > deploy_targets.json

      - name: Deploy all apps inside their LXCs
        if: github.ref == 'refs/heads/master'
        run: |
          set -euo pipefail

          # Build HTTPS clone URL for this repo
          REPO_URL="https://github.com/tabman83/homelab.git"

          echo "[deploy] Using repo: ${REPO_URL}"
          echo "[deploy] Reading deploy_targets.json..."
          cat deploy_targets.json

          # Each line: app_name:vmid:app_dir
          APPS=$(jq -r 'to_entries[] | "\(.key):\(.value.vmid):\(.value.app_dir)"' deploy_targets.json)

          for entry in $APPS; do
            APP_NAME=$(echo "$entry" | cut -d: -f1)
            VMID=$(echo "$entry"     | cut -d: -f2)
            APP_DIR=$(echo "$entry"  | cut -d: -f3)

            echo "[deploy] Deploying app '${APP_NAME}' to CT ${VMID} (dir: ${APP_DIR})..."

            ssh proxmox "REPO_URL=${REPO_URL} APP_NAME=${APP_NAME} VMID=${VMID} APP_DIR=${APP_DIR} bash -s" << 'EOF'
            set -euo pipefail

            # This runs on the Proxmox controller node (e.g. pve).
            # First, make sure jq is available.
            if ! command -v jq >/dev/null 2>&1; then
              echo "[controller] Installing jq..."
              apt-get update
              apt-get install -y jq
            fi

            echo "[controller:$APP_NAME] Finding node for CT $VMID..."

            NODE=$(pvesh get /cluster/resources --type vm --output-format json \
              | jq -r ".[] | select(.vmid == ${VMID} and .type==\"lxc\") | .node")

            if [ -z "$NODE" ] || [ "$NODE" = "null" ]; then
              echo "[controller:$APP_NAME] ERROR: CT $VMID not found in cluster" >&2
              exit 1
            fi

            echo "[controller:$APP_NAME] CT $VMID currently lives on node '$NODE'"

            HOSTNAME=$(hostname)

            if [ "$NODE" = "$HOSTNAME" ]; then
              echo "[controller:$APP_NAME] Running on local node '$HOSTNAME' with pct exec"
              # We are on the right node – run pct exec locally
              pct exec "$VMID" -- env REPO_URL="$REPO_URL" APP_NAME="$APP_NAME" APP_DIR="$APP_DIR" bash -s << 'INNER'
              set -euo pipefail

              REPO_DIR="/opt/homelab/homelab"
              APP_PATH="${REPO_DIR}/${APP_DIR}"

              echo "[bootstrap:$APP_NAME] Installing prerequisites if needed..."

              if ! command -v git >/dev/null 2>&1; then
                apt-get update
                apt-get install -y ca-certificates curl gnupg git
              fi

              if ! command -v docker >/dev/null 2>&1; then
                install -m 0755 -d /etc/apt/keyrings || true
                if [ ! -f /etc/apt/keyrings/docker.gpg ]; then
                  curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                  chmod a+r /etc/apt/keyrings/docker.gpg
                fi

                echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian $(. /etc/os-release && echo "$VERSION_CODENAME") stable" > /etc/apt/sources.list.d/docker.list

                apt-get update
                apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              fi

              echo "[bootstrap:$APP_NAME] Cloning or updating repo at $REPO_DIR..."

              mkdir -p "$(dirname "$REPO_DIR")"

              if [ ! -d "$REPO_DIR/.git" ]; then
                rm -rf "$REPO_DIR"
                git clone "$REPO_URL" "$REPO_DIR"
              else
                cd "$REPO_DIR"
                git pull --rebase
              fi

              cd "$APP_PATH"
              chmod +x deploy.sh || true

              echo "[bootstrap:$APP_NAME] Running deploy.sh in $APP_PATH..."
              ./deploy.sh

              echo "[bootstrap:$APP_NAME] Done."
          INNER

            else
              echo "[controller:$APP_NAME] CT $VMID is on node '$NODE' – SSHing there to run pct exec"

              ssh "$NODE" env REPO_URL="$REPO_URL" APP_NAME="$APP_NAME" APP_DIR="$APP_DIR" VMID="$VMID" bash -s << 'INNER'
              set -euo pipefail

              REPO_DIR="/opt/homelab/homelab"
              APP_PATH="${REPO_DIR}/${APP_DIR}"

              echo "[node:$APP_NAME] Running on node $(hostname), will exec into CT $VMID"

              if ! command -v git >/dev/null 2>&1; then
                apt-get update
                apt-get install -y ca-certificates curl gnupg git
              fi

              if ! command -v docker >/dev/null 2>&1; then
                install -m 0755 -d /etc/apt/keyrings || true
                if [ ! -f /etc/apt/keyrings/docker.gpg ]; then
                  curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                  chmod a+r /etc/apt/keyrings/docker.gpg
                fi

                echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian $(. /etc/os-release && echo "$VERSION_CODENAME") stable" > /etc/apt/sources.list.d/docker.list

                apt-get update
                apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              fi

              if ! command -v pct >/dev/null 2>&1; then
                echo "[node:$APP_NAME] ERROR: pct command not found on node $(hostname)" >&2
                exit 1
              fi

              pct exec "$VMID" -- env REPO_URL="$REPO_URL" APP_NAME="$APP_NAME" APP_DIR="$APP_DIR" bash -s << 'INNER2'
              set -euo pipefail

              REPO_DIR="/opt/homelab/homelab"
              APP_PATH="${REPO_DIR}/${APP_DIR}"

              echo "[bootstrap:$APP_NAME] Installing prerequisites if needed..."

              if ! command -v git >/dev/null 2>&1; then
                apt-get update
                apt-get install -y ca-certificates curl gnupg git
              fi

              if ! command -v docker >/dev/null 2>&1; then
                install -m 0755 -d /etc/apt/keyrings || true
                if [ ! -f /etc/apt/keyrings/docker.gpg ]; then
                  curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                  chmod a+r /etc/apt/keyrings/docker.gpg
                fi

                echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian $(. /etc/os-release && echo "$VERSION_CODENAME") stable" > /etc/apt/sources.list.d/docker.list

                apt-get update
                apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              fi

              echo "[bootstrap:$APP_NAME] Cloning or updating repo at $REPO_DIR..."

              mkdir -p "$(dirname "$REPO_DIR")"

              if [ ! -d "$REPO_DIR/.git" ]; then
                rm -rf "$REPO_DIR"
                git clone "$REPO_URL" "$REPO_DIR"
              else
                cd "$REPO_DIR"
                git pull --rebase
              fi

              cd "$APP_PATH"
              chmod +x deploy.sh || true

              echo "[bootstrap:$APP_NAME] Running deploy.sh in $APP_PATH..."
              ./deploy.sh

              echo "[bootstrap:$APP_NAME] Done."
          INNER2
          INNER
            fi
          EOF
          done

      # Bring down the tunnel
      - name: Bring down WireGuard
        if: always()
        run: sudo ip link set down dev wg0
